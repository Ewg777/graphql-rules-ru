## 5. Правила списков

Я не встречал ни одного АПИ, которое бы не возвращало список элементов. Либо это постраничная листалка, либо что-то построенное на курсорах для бесконечных списков. Списки надо фильтровать, сортировать, ограничивать кол-во возвращаемых элементов. Сам GraphQL никак не ограничивает свободу реализации, но для того чтобы сформировать некое единообразие, необходимо завести стандарт.

### <a name="rule-5.1"></a> 5.1. Для фильтрации списков используйте аргумент `filter`, который содержит в себе все доступные фильтры.

Как вы думаете, как лучше организовать фильтрацию?

```graphql
type Query {
  articles(authorId: Int, tags: [String], lang: LangEnum): [Article]
}
```

или через аргумент `filter` с типом `ArticleFilter`:

```graphql
type Query {
  articles(filter: ArticleFilter): [Article]
}

input ArticleFilter {
  authorId: Int
  tags: [String]
  lang: LangEnum
}
```

Конечно, лучше всего организовать через дополнительный тип `ArticleFilter`. На это есть несколько причин:

- если вы будете добавлять новые аргументы не относящиеся к фильтрации (сортировка, лимит, офсет, номер страницы, курсор, язык и прочее), то ваши аргументы не будут путаться друг с другом
- на клиенте для статического анализа вы получите `ArticleFilter` тип. Иначе клиенты будут вынуждены собирать такой тип вручную, что чревато ошибками
- тупо легче читать и воспринимать вашу схему, когда в ней 3-5 аргументов а не 33 аргумента с возможной фильтрацией. Есть аргумент `filter` и если нужно, провались в него и там уже посмотри все 33 поля для фильтрации
- этот фильтр можно переиспользовать несколько раз в вашем апи, если список статей можно запросить из нескольких мест

Также важно договориться как назвать поле для фильтрации. А то если у вас 5, 10 или 100 разработчиков, то на выходе в схеме у вас появиться куча названий для аргумента фильтрации — `filter`, `where`, `condition`, `f` и прочий нестандарт. Если учитывать что есть базы SQL и noSQL, есть всякие кэши и прочие сервисы, то **самым адекватным именем для аргумента фильтрации является — `filter`**. Оно понятно и подходит для всех! А вот этот `where` в основном для SQL-бэкендеров.

### <a name="rule-5.2"></a> 5.2. Для сортировки списков используйте аргумент `sort`, который должен быть `Enum` или `[Enum!]`.

Когда в списке много записей, то может потребоваться сортировка по полю. А иногда требуется сортировка по нескольким полям.

Для начала команде необходимо выбрать имя для аргумента сортировки. На ум приходит следующие популярные названия — `sort`, `order`, `orderBy`. Т.к. слово `order` переводиться не только как порядок, но и как заказ; и используется в основном только в реляционных базах данных. **То лучшим выбором имени для поля сортировки будет — `sort`.** Оно однозначно трактуется и будет понятно всем.

Когда с именем аргумента определились, то необходимо выбрать тип для аргумента сортировки:

- Если взять `String`, то фронтендеру будет тяжело указать правильные значения и при этом мы не получаем возможности валидации параметров средствами GraphQL.
- Можно создать input-тип `input ArticleSort { field: SortFieldsEnum, order: AscDescEnum }` — структура у которой можно выбрать имя поля и тип сортировки. Но такой подход не подойдет, если у вас появится полнотекстовая сортировка или сортировка по близости. У них просто нет значения DESC (обратной сортировки).
- Остается один самый простой и верный способ — использовать `Enum` для перечисления списка доступных сортировок `enum ArticleSort { ID_ASC, ID_DESC, TEXT_MATCH, CLOSEST }`. В таком случае вы можете явно указать доступные способы для сортировки.

Также если внимательно прочитать как [объявляются типы Enum](../types/README.md#enumeration-types) на сервере, то помимо ключа `ID_ASC`, можно задать значение `id ASC` (для SQL), либо `{ id: 1 }` (для NoSQL). Т.е. клиенты видят унифицированный ключ `ID_ASC`, а вот на сервере в resolve-методе вы получаете уже готовое значение для подстановки в запрос. Конвертация ключа сортировки происходит внутри Enum-типа, что в свою очередь сделает код вашего resolve-метод меньше и чище.

Ну а теперь, чтобы иметь возможность сортировать по нескольким полям, нам просто необходимо дать возможность передавать массив значений для сортировки. В итоге получим следующее объявление сортировки:

```graphql
type Query {
  articles(sort: [ArticleSort!]): [Article]
}

enum ArticleSort {
  ID_ASC, ID_DESC, TEXT_MATCH, CLOSEST
}
```

### <a name="rule-5.3"></a> 5.3. Для ограничения возвращаемых элементов в списке используйте аргументы `limit` со значением по умолчанию и `skip`.

С ограничением кол-ва элементов в списке и возможностью сдвига все банально просто. Используйте аргументы с названиями `limit` и `skip`. Единственно для лимита хорошо бы задать значение по умолчанию, чтоб клиенты могли не указывать это значение. И сделать `limit` обязательным, чтоб нельзя было передать `null`.

```graphql
type Query {
  articles(
    limit: Int! = 20
    skip: Int
  ): [Article]
}
```

### <a name="rule-5.4"></a> 5.4. Для пагинации используйте аргументы `page`, `perPage` и возвращайте output-тип с полями `items` с массивом элементов и `pageInfo` с метаданными для удобной отрисовки страниц на клиенте.

Альтернативой для ограничения возвращаемых элементов в списке `limit` и `skip` может выступить пагинация.

Для пагинации лучше всего использовать аргументы с именами `page` и `perPage`, которые NonNull и co значением по умолчанию:

```graphql
type Query {
  articles(
    page: Int! = 1
    perPage: Int! = 20
  ): [Article]
}
```

Но если вы остановитесь только на аргументах `page` и `perPage`, то польза от вашей пагинации для клиентов будет ничем не лучше `limit` и `skip`. Для того, чтобы клиентское приложение могло отрисовать нормально пагинацию, ему необходимо предоставить не только сами элементы списка, но и дополнительные метаданные как минимум с общим кол-вом страниц и записей. Для метаданных пагинации необходимо завести следующий общий тип `PaginationInfo`:

```graphql
type PaginationInfo {
  # Total number of pages
  totalPages: Int!

  # Total number of items
  totalItems: Int!

  # Current page number
  page: Int!

  # Number of items per page
  perPage: Int!

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!
}
```

Сакральный смысл всех этих полей в `PaginationInfo`, чтоб легко можно было отрисовать пагинацию на клиенте без дополнительных вычислений. А еще **представьте себе лагающий интернет и нервного пользователя** – если он в пагинации успел щелкнуть 50 раз по разным страницам за 5 секунд, то что прилетит в ответ от сервера, мы даже представить себе не можем, тем более отрисовать правильно пагинацию. Поэтому и необходима детальная метаинформация от сервера.

В случае предоставления метаданных для пагинации мы уже не можем взять просто и вернуть массив найденных элементов. Нам необходимо будет завести новый тип `ArticlePagination` для возврата результатов с сервера. И вот здесь опять появляется повод к выработке стандарта:

```graphql
type Query {
  articles(
    page: Int! = 1
    perPage: Int! = 20
  ): ArticlePagination
}

type ArticlePagination {
  # Array of objects.
  items: [Article]!

  # Information to aid in pagination.
  pageInfo: PaginationInfo!
}
```

У `ArticlePagination` должно быть как минимум два поля:

- `items` — NonNull-массив элементов
- `pageInfo` — NonNull-объект с метаданными пагинации `totalPages`, `totalItems`, `page`, `perPage`

### <a name="rule-5.5"></a> 5.5. Для бесконечных списков (infinite scroll) используйте [Relay Cursor Connections Specification](https://facebook.github.io/relay/graphql/connections.htm).

У пагинации есть недостаток, когда добавляются или удаляются элементы, то при переходе на следующую страницу вы можете столкнуться с проблемами:

- under-fetching — это когда в начале списка удаляется элемент, и при переходе на следующую страницу клиент пропускает запись, которая "убежала" на предыдущую страницу
- over-fetching — это когда добавляются новые записи в начало списка, и при переходе на следующую страницу клиент повторно видит записи которые были на предыдущей странице

Для решения этой проблемы Facebook разработал спецификацию [Relay Cursor Connections Specification](https://facebook.github.io/relay/graphql/connections.htm). Она идеально подходит для создания бесконечных (infinite scroll) списков. А коль есть спецификация, то значит есть некий стандарт которому может следовать команда разработчиков и не изобретать велосипеды.

Правда вид GraphQL-запросов у infinite scroll не очень, на первый взгляд он выглядит непонятно и требует объяснения для клиентов:

```graphql
{
  articles(first: 10, after: "opaqueCursor") {
    edges {
      cursor
      node { # только на 3-уровне вложенности получаем данные записи
        id
        name
      }
    }
    pageInfo {
      hasNextPage
    }
  }
}
```

Поэтому если у вас есть возможность для ваших клиентов помимо Infinite Scroll передать еще и обычную пагинацию – то они вам только спасибо скажут за возможность выбора в получении данных.
