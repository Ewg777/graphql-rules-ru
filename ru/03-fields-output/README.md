## 3. Правила полей (Output)

В GraphQL поля используются для передачи данных с сервера на клиент. Они могут быть описаны обычными скалярнвми типами, а также сложными структурами – Output-типами (GraphQLObjectType).

### <a name="rule-3.1"></a> 3.1. Давайте полям понятные смысловые имена, а не то как они реализованы.

Необходимо полям давать понятные имена. Это очень простое и банальное правило. К примеру, у нас есть следующий тип:

```diff
type Meeting {
-  body_htML: String # BAD
+  description: HTML # GOOD
}
```

Человек который в первый раз видит тип `Meeting`, будет гадать, что конкретно хранится в поле `bodyHtml`. Здорово если бэкендеры не ленятся и оставляют описание к полям. Но черт возьми, можно же поле в АПИ назвать `description`, а в базе пусть хранится как `bodyHtml`, тогда и без документации все понятно.

Часто в базах и моделях бывает бардак в именовании, и чтоб перед [Доном Педро не было стыдно](https://pikabu.ru/story/anekdot_3660462) – в АПИ можно все правильно заммапить в красивые и понятные имена полей.

### <a name="rule-3.2"></a> 3.2. Делайте поля обязательными `NonNull`, если данные в поле возвращаются при любой ситуации.

Помечая поля в вашей схеме как `NonNull` (обязательные) позволят клиентам при статическом анализе делать меньше проверок в коде. Если вдруг бэкендер не вернет данные по обязательному полю, то GraphQL вернет ошибку о том, что данных нет. При этом занулит родительский объект. И если родительский объект тоже обязателен, то выбросит ошибку еще выше. В любом случае клиент не получит объект (тип) без данных для обязательного поля.

Также это правило распространяется на возвращение массивов.

```graphql
type MyLists {
  list1: [String]   # [], [null], null
  list2: [String]!  # [], [null]
  list3: [String!]  # [], null
  list4: [String!]! # []                <-- BETTER!
}
```

Если вы всегда возвращаете массив, то пометьте его как `[SomeType]!` (`new GraphQLNonNull(new GraphQLList(SomeType))`). по умолчанию у GraphQL все поля nullable, поэтому клиентам необходимо сперва проверить наличие массива, а потом по нему проходиться. Иногда это очень загрязняет код. Поэтому если вы всегда возвращаете массив, то помечайте поле как NonNull. При этом сам массив внутри себя может содержать null элементы и если не может, то помечайте его как `[SomeType!]!` (`new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(SomeType)))`).

Если `boolean` не делать обязательным, то тогда у него может быть три состояния true/false/null:

```graphql
type MyBool {
  bool1: Boolean  # true, false, null
  bool2: Boolean! # true, false
}
```

### <a name="rule-3.3"></a> 3.3. Достигайте максимального описания обязательных полей.

#### Проблема:

Бывают случаи, когда в зависимости от определенного значения мы ожидаем те или иные параметры.
К примеру, у нас есть жалобы `Claim` которые поступают либо по почте, либо по телефону. Поле `operatorCode` содержит в себе код оператора, который принял звонок. Т.е. оно всегда заполнено если указан телефон, и пустое если жалоба пришла по почте.

```graphql
type Claim {
  text: String!
  phone: String
  operatorCode: String
  email: String
}
```

#### Цель:

Укажем тип жалобы `Claim` таким образом, чтобы максимально описать поля, которые мы обязательно получим в том или ином случае. Благодаря этому, клиенту придется делать меньше проверок.

#### Решения:

В примере схемы, указанной выше, Вы можете увидеть отсутствие описания обязательных полей, т.е. все поля являются nullable (кроме text, о котором речь не пойдет), поэтому клиенту придется дополнительно проверять каждое значение перед работой с ним.

##### Существует несколько решений этой проблемы:

1) Сгруппировать взаимосвязанные поля на уровень ниже в новый output-тип
2) Использовать union-типы в связке с fragments

##### Решение 1: Группировка взаимосвязанных полей вместе в новый output-тип

Выносите взаимосвязанные поля на уровень ниже в новый output-тип. Берем поля `phone` и `operatorCode` и группируем их в типе `ClaimByPhone`. Тогда нашу схему можно представить в следующем виде:

```graphql
type Claim {
  text: String!
  byPhone: ClaimByPhone
  byMail: ClaimByMail
}

type ClaimByPhone {
  phone: String!
  operatorCode: String!
}

type ClaimByMail {
  email: String!
}
```

Обратите внимание, что если поле `byPhone` не пустое, то оно обязательно будет содержать номера телефона и кода оператора. Становится возможным взаимосвязанные поля делать обязательными.

##### Решение 2: Использование Union типов в связке с fragments

Если вы не знакомы с Union типами, их можно описать как "либо либо". Подробнее про Union типы следует почитать [тут](https://github.com/nodkz/conf-talks/tree/master/articles/graphql/types#union-types).

```graphql
# Опишем базовый тип для жалобы
type ClaimBase {
  text: String!
}

# Опишем тип жалобы, пришедшей по телефону
type ClaimByPhone implements ClaimBase {
  text: String!
  phone: String!
  operatorCode: String!
}

# Опишем тип жалобы, пришедшей по почте
type ClaimByMail implements ClaimBase {
  text: String!
  email: String!
}

# Опишем union тип жалобы
union Claim = ClaimByPhone | ClaimByMail

```

Теперь клиент запрашивает claim с помощью фрагментов, запрос выглядит так:

```graphql
query {
  claim {
    ... on ClaimByPhone {
      text
      phone
      operatorCode
    }
    ... on ClaimByMail {
      text
      email
    }
  }
}
```

Такой подход делает схему более строгой, облегчает фронтендерам восприятие взаимосвязанных полей.
