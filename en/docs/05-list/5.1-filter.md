### <a name="rule-5.1"></a> 5.1. Use `filter` argument to filter list

Consider two approaches to organizing filtering. One where all arguments are on the same level:

```graphql
type Query {
  articles(authorId: Int, tags: [String], lang: LangEnum): [Article]
}
```

and another one where there is a single argument `filter` of type `ArticleFilter`:

```graphql
type Query {
  articles(filter: ArticleFilter): [Article]
}

input ArticleFilter {
  authorId: Int
  tags: [String]
  lang: LangEnum
}
```

Combining filter options inside one `filter` argument of type <0>ArticleFilter</0> is better. На это есть несколько причин:

- non-filter arguments (e.g. sorting, limit, offset, page number, cursor, language) are clearly separated from filter arguments
- consumers will get a `ArticleFilter` type for static analysis. This also reduces the likelihood of errors on the client
- it's much easier to reason about GraphQL API when fields have a small number of 3-5 arguments. You can always locate the `filter` argument and if needed view all the available options by looking at the specific type
- you can use this filter multiple times if you want to request articles from a multiple places

It's important to have a naming convention for filtration field. In the big teams, it could be some variations like `filter`, `where`, `condition`, `f`. If we consider that there are SQL and NoSQL databases, there are caches and other services, then **the most appropriate name for the filtering argument is `filter` **. It is understandable and suitable for everyone! А вот этот `where` в основном для SQL-бэкендеров.