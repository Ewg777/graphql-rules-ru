### <a name="rule-5.1"></a> 5.1. To filter the lists, use the `filter` argument, which contains all the available filters.

What is the best approach to organize filtering?

```graphql
type Query {
  articles(authorId: Int, tags: [String], lang: LangEnum): [Article]
}
```

or through the argument `filter` with `ArticleFilter` type:

```graphql
type Query {
  articles(filter: ArticleFilter): [Article]
}

input ArticleFilter {
  authorId: Int
  tags: [String]
  lang: LangEnum
}
```

The best way to organize it is to use an additional `ArticleFilter` type. There are the reasons:

- if you add new non-filtering arguments (sorting, limit, offset, page number, cursor, language, etc.), your arguments aren't be mixed up
- you'll have `ArticleFilter` type for static analysis on a client side. Otherwise, clients will need to build it by themselves, which could be the reason for errors
- it's far easier to understand your schema when it has just a 3 to 5 arguments. You can process any number of fields with `filter` argument
- you can use this filter multiple times if you want to request articles from a multiple places

It's important to have a naming convention for filtration field. In the big teams, it could be some variations like `filter`, `where`, `condition`, `f`. If we consider that there are SQL and NoSQL databases, there are caches and other services, then **the most appropriate name for the filtering argument is `filter` **. It is understandable and suitable for everyone! А вот этот `where` в основном для SQL-бэкендеров.