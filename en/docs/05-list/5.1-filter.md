### <a name="rule-5.1"></a> 5.1. Use `filter` argument to filter list

Consider two approaches to organizing filtering. One where all arguments are on the same level:

```graphql
type Query {
  articles(authorId: Int, tags: [String], lang: LangEnum): [Article]
}
```

and another one where there is a single argument `filter` of type `ArticleFilter`:

```graphql
type Query {
  articles(filter: ArticleFilter): [Article]
}

input ArticleFilter {
  authorId: Int
  tags: [String]
  lang: LangEnum
}
```

Combining filter options inside one `filter` argument of type <0>ArticleFilter</0> is better. На это есть несколько причин:

- non-filter arguments (e.g. sorting, limit, offset, page number, cursor, language) are clearly separated from filter arguments
- you'll have `ArticleFilter` type for static analysis on a client side. Otherwise, clients will need to build it by themselves, which could be the reason for errors
- it's far easier to understand your schema when it has just a 3 to 5 arguments. You can process any number of fields with `filter` argument
- you can use this filter multiple times if you want to request articles from a multiple places

It's important to have a naming convention for filtration field. In the big teams, it could be some variations like `filter`, `where`, `condition`, `f`. If we consider that there are SQL and NoSQL databases, there are caches and other services, then **the most appropriate name for the filtering argument is `filter` **. It is understandable and suitable for everyone! А вот этот `where` в основном для SQL-бэкендеров.