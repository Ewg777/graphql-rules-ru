### <a name="rule-5.1"></a> 5.1. To filter the lists, use the `filter` argument, which contains all the available filters.

What is the best approach to organize filtering?

```graphql
type Query {
  articles(authorId: Int, tags: [String], lang: LangEnum): [Article]
}
```

or through the argument `filter` with `ArticleFilter` type:

```graphql
type Query {
  articles(filter: ArticleFilter): [Article]
}

input ArticleFilter {
  authorId: Int
  tags: [String]
  lang: LangEnum
}
```

The best way to organize it is to use an additional `ArticleFilter` type. There are the reasons:

- if you add new non-filtering arguments (sorting, limit, offset, page number, cursor, language, etc.), your arguments aren't be mixed up
- you'll have `ArticleFilter` type for static analysis on a client side. Otherwise, clients will need to build it by themselves, which could be the reason for errors
- it's far easier to understand your schema when it has just a 3 to 5 arguments. You can process any number of fields with `filter` argument
- you can use this filter multiple times if you want to request articles from a multiple places

Также важно договориться как назвать поле для фильтрации. А то если у вас 5, 10 или 100 разработчиков, то на выходе в схеме у вас появиться куча названий для аргумента фильтрации — `filter`, `where`, `condition`, `f` и прочий нестандарт. Если учитывать что есть базы SQL и noSQL, есть всякие кэши и прочие сервисы, то **самым адекватным именем для аргумента фильтрации является — `filter`**. Оно понятно и подходит для всех! А вот этот `where` в основном для SQL-бэкендеров.