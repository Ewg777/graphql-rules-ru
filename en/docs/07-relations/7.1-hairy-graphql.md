### <a name="rule-7.1"></a> 7.1. GraphQL schema should be "hairy"

Clients are now actively using a component approach. And if you look at Facebook Relay and how they use the composition of components and GraphQL fragments, you will notice how they broke the paradigm of writing a query "at the top" and offered a more convenient and error-resistant solution:

- each component has its own GraphQL fragment (it can have several fragments)
- GraphQL fragment contains only those fields that are necessary for the current component
- to form a GraphQL query, they compose components and fragments

It turns out that the final GraphQL query is written from the bottom up – depending on what components are used on the page, the necessary GraphQL fragments will be taken. If someone at the bottom decides to extend his component with additional data, he will simply expand the list of fields in the GraphQL fragment of this component. And, accordingly, automatically all GraphQL queries that use this fragment, will start to retrieve the additional fields. As we can see the query begins to form at the bottom, where the data will be used, and large fragments are already glued up. At the end of May 2019 I will speak in St. Petersburg and Moscow, where I will reveal this topic in more detail. Here I will for sure add a link to the video.

For GraphQL fragments working fine on the client, you need a server that will indicate in the scheme as many relationships as possible between its types. Как бы оправдывали слово `Graph`. Иначе если схема содержит мало связей и похоже не дерево, то ее можно называть `RestQL`.

**`Волосатый GraphQL` (`Hairy GraphQL`) – это GraphQL-схема, которая содержит много связей между типами.**

В качестве примера можно привести сильно-связную, "волосатую" схему GitHub АПИ (посмотрите сколько связей между типами):

![hairy-github](https://user-images.githubusercontent.com/1946920/57200267-b0ee2a80-6fab-11e9-9c76-6053abe48ecd.jpg)

А в качестве слабо-связного, "лысого" `RestQL` АПИ за пример сойдет вот такое древовидное АПИ:

![non-hairy-amazon](https://user-images.githubusercontent.com/1946920/57200270-b3e91b00-6fab-11e9-9d65-e6f794ea42f5.jpg)

Данные картинки сделаны с помощью инструмента [graphql-voyager](https://apis.guru/graphql-voyager/) от Ivan Goncharov и Roman Gotsiy. Можно загрузить интроспекцию любой схемы и визуально оценить ее – "волосатая" она или "лысая".

As we can see чем больше связей в вашей схеме, тем легче фронтендерам делать запросы используя GraphQL-фрагменты. К сожалению, на "лысой" схеме применить фрагментный подход нормально не получится. В слабосвязном графе сложнее из одной вершины достать другую. Поэтому фронтендеры будут вынуждены писать новые запросы через корень, чтобы получить необходимые данные. А не просто дозапросить у текущего Типа по какому-то полю связанные данные с другим Типом. Одним словом, обратно возвращаемся в каменный 2000 год REST API.