### <a name="rule-7.1"></a> 7.1. GraphQL-схема должна быть "волосатой"

Фронтендеры активно сейчас используют компонентный подход. И если посмотреть на фейсбуковский [Relay](https://facebook.github.io/relay/docs/en/fragment-container#container-composition) и как они используют композицию компонентов и GraphQL-фрагментов, то вы заметите как они сломали парадигму написания запроса "наверху" и предложили более удобное и устойчивое к ошибкам решение:

- каждый компонент имеет свой GraphQL-фрагмент (может иметь несколько фрагментов)
- GraphQL-фрагмент содержит только те поля, которые необходимы текущей компоненте
- чтобы сформировать GraphQL-запрос, они композируют компоненты и фрагменты

Получается, что конечный GraphQL-запрос пишется снизу-вверх – в зависимости от того, какие компоненты используются на странице, будут взяты необходимые GraphQL-фрагменты. Если кто-то внизу решит расширить свою компоненту дополнительными данными, то он просто расширит список полей в GraphQL-фрагменте этой компоненты. И соответственно автоматически все GraphQL-запросы, которые используют этот фрагмент, начнут запрашивать дополнительные поля. Т.е. запрос как бы начинается формироваться внизу, где данные будут использоваться, а наверх уже склеиваются большие фрагменты. В конце мая 2019 я буду выступать в Санкт-Петербурге и Москве, где буду раскрывать эту тему подробнее. Здесь обязательно добавлю ссылку на видео.

Чтобы GraphQL-фрагменты хорошо работали на фронтенде, необходимо чтобы бэкендеры указывали в своей схеме как можно больше связей между своими типами. Как бы оправдывали слово `Graph`. Иначе если схема содержит мало связей и похоже не дерево, то ее можно называть `RestQL`.

**`Волосатый GraphQL` (`Hairy GraphQL`) – это GraphQL-схема, которая содержит много связей между типами.**

В качестве примера можно привести сильно-связную, "волосатую" схему GitHub АПИ (посмотрите сколько связей между типами):

![hairy-github](https://user-images.githubusercontent.com/1946920/57200267-b0ee2a80-6fab-11e9-9c76-6053abe48ecd.jpg)

А в качестве слабо-связного, "лысого" `RestQL` АПИ за пример сойдет вот такое древовидное АПИ:

![non-hairy-amazon](https://user-images.githubusercontent.com/1946920/57200270-b3e91b00-6fab-11e9-9d65-e6f794ea42f5.jpg)

Данные картинки сделаны с помощью инструмента [graphql-voyager](https://apis.guru/graphql-voyager/) от Ivan Goncharov и Roman Gotsiy. Можно загрузить интроспекцию любой схемы и визуально оценить ее – "волосатая" она или "лысая".

Т.е. чем больше связей в вашей схеме, тем легче фронтендерам делать запросы используя GraphQL-фрагменты. К сожалению, на "лысой" схеме применить фрагментный подход нормально не получится. В слабосвязном графе сложнее из одной вершины достать другую. Поэтому фронтендеры будут вынуждены писать новые запросы через корень, чтобы получить необходимые данные. А не просто дозапросить у текущего Типа по какому-то полю связанные данные с другим Типом. Одним словом, обратно возвращаемся в каменный 2000 год REST API.