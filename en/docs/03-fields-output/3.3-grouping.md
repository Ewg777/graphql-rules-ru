### <a name="rule-3.3"></a> 3.3. Group related fields

#### Problem:

There are cases where depending on a particular value we expect certain parameters. For instance, we have complaints `Claim` which arrive either by mail or by phone. The `operatorCode` field contains the code of the operator who received the call. As we can see it is always filled in if the phone number is filled, and empty if the complaint came by the mail.

```graphql
type Claim {
  text: String!
  phone: String
  operatorCode: String
  email: String
}
```

#### Purpose:

Let's set the type of complaint `Claim` in such a way to clearly describe the fields that we definitely get. In this case, we reduce the number of checkings on the client side.

#### Solutions:

In the example above you can see the lack of required fields descriptions, i.e. every field is nullable (except the text), that's why the client needs to check every value before processing it.

##### There are a few solutions:

1) Group related fields one level lower into new output type 2) Use union types with fragments

##### Solution 1: Group related fields one level lower into new output type

Move interconnected fields one level lower into a new output type. Let's group `phone` and `operatorCode` to `ClaimByPhone` type. Then our scheme can be represented as follows:

```graphql
type Claim {
  text: String!
  byPhone: ClaimByPhone
  byMail: ClaimByMail
}

type ClaimByPhone {
  phone: String!
  operatorCode: String!
}

type ClaimByMail {
  email: String!
}
```

Let's pay attention if `byPhone` isn't empty then it surely contains a phone number and operator code. It becomes possible to make interrelated fields mandatory.

##### Solution 2: Consider using union-types along with fragments

If you are not familiar with Union types, you can use them as "or either". You can find more details about Union types [here](https://github.com/nodkz/conf-talks/tree/master/articles/graphql/types#union-types).

```graphql
# Basic type for complaint
type ClaimBase {
  text: String!
}

# Type for complaint came by phone
type ClaimByPhone implements ClaimBase {
  text: String!
  phone: String!
  operatorCode: String!
}

# Type for complaint came by email
type ClaimByMail implements ClaimBase {
  text: String!
  email: String!
}

# Union type for a complaint
union Claim = ClaimByPhone | ClaimByMail

```

Then the client requests claim with fragments as follows:

```graphql
query {
  claim {
    ... on ClaimByPhone {
      text
      phone
      operatorCode
    }
    ... on ClaimByMail {
      text
      email
    }
  }
}
```

This approach makes the scheme more strict, makes it easier for front-devs to deal with interconnected fields.