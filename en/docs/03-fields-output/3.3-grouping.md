### <a name="rule-3.3"></a> 3.3. Достигайте максимальной группировки взаимосвязанных полей.

#### Проблема:

There are cases where depending on a particular value we expect certain parameters. For instance, we have complaints `Claim` which arrive either by mail or by phone. The `operatorCode` field contains the code of the operator who received the call. As we can see it is always filled in if the phone number is filled, and empty if the complaint came by the mail.

```graphql
type Claim {
  text: String!
  phone: String
  operatorCode: String
  email: String
}
```

#### Purpose:

Let's set the type of complaint `Claim` in such a way to clearly describe the fields that we definitely get. In this case, we reduce the number of checkings on the client side.

#### Solutions:

In the example above you can see the lack of required fields descriptions, i.e. все поля являются nullable (кроме text, о котором речь не пойдет), поэтому клиенту придется дополнительно проверять каждое значение перед работой с ним.

##### Существует несколько решений этой проблемы:

1) Сгруппировать взаимосвязанные поля на уровень ниже в новый output-тип 2) Использовать union-типы в связке с fragments

##### Решение 1: Группировка взаимосвязанных полей вместе в новый output-тип

Выносите взаимосвязанные поля на уровень ниже в новый output-тип. Берем поля `phone` и `operatorCode` и группируем их в типе `ClaimByPhone`. Тогда нашу схему можно представить в следующем виде:

```graphql
type Claim {
  text: String!
  byPhone: ClaimByPhone
  byMail: ClaimByMail
}

type ClaimByPhone {
  phone: String!
  operatorCode: String!
}

type ClaimByMail {
  email: String!
}
```

Обратите внимание, что если поле `byPhone` не пустое, то оно обязательно будет содержать номера телефона и кода оператора. Становится возможным взаимосвязанные поля делать обязательными.

##### Решение 2: Использование Union типов в связке с fragments

Если вы не знакомы с Union типами, их можно описать как "либо либо". Подробнее про Union типы следует почитать [тут](https://github.com/nodkz/conf-talks/tree/master/articles/graphql/types#union-types).

```graphql
# Опишем базовый тип для жалобы
type ClaimBase {
  text: String!
}

# Опишем тип жалобы, пришедшей по телефону
type ClaimByPhone implements ClaimBase {
  text: String!
  phone: String!
  operatorCode: String!
}

# Опишем тип жалобы, пришедшей по почте
type ClaimByMail implements ClaimBase {
  text: String!
  email: String!
}

# Опишем union тип жалобы
union Claim = ClaimByPhone | ClaimByMail

```

Теперь клиент запрашивает claim с помощью фрагментов, запрос выглядит так:

```graphql
query {
  claim {
    ... on ClaimByPhone {
      text
      phone
      operatorCode
    }
    ... on ClaimByMail {
      text
      email
    }
  }
}
```

Такой подход делает схему более строгой, облегчает фронтендерам восприятие взаимосвязанных полей.