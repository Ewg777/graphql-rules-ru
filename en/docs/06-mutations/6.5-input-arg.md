### <a name="rule-6.5"></a> 6.5. In mutations, put all variables into one unique input argument.

Try to use one input argument in mutations. It is much easier to use on the client side. The client will need to pass just one variable, not a wagon for each argument in the mutation.

```graphql
# Good:
mutation ($input: UpdatePostInput!) {
  updatePost(input: $input) { ... }
}

# Not so good – it's harder to write a query (duplication of variables)
mutation ($id: ID!, $newText: String, ...) {
  updatePost(id: $id, newText: $newText, ...) { ... }
}
```

If the mutation has at the top level only one or two arguments, then it's become more readable. At the same time, without additional costs, except for a few additional keystrokes, the nesting of the arguments allows you to fully use the capabilities of GraphQL, as a version-less API. Nesting gives you the ability to expand the types over time as well as the avoid conflicts in the naming of the fields.

Also, static typing with Typescript or Flowtype makes it much easier to track changes in your API when your code binds to a single complex type rather than a set of disparate arguments.

Думайте о вложении аргументов в один общий аргумент `input`, как об инвестиции в будущие изменения вашего GraphQL API.

При этом не экономьте на типах – для каждой мутации заводите свой Input-тип с уникальным именем. Это позволит вам менять мутации, не оглядываясь на то, что новая семантика может поломать другие мутации.

Также по состоянию на конец 2018 года в спецификации GraphQL нет возможности деприкейтить аргументы (помечать их как устаревшие). Но вот деприкейтить поля внутри типа `input` можно. Это еще один повод использовать аргумент `input` со вложенностью.