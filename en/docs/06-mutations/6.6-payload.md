### <a name="rule-6.6"></a> 6.6. Every mutation should have an unique payload type.

Use an unique payload type for every mutation. You'll be able to expand mutation response with additional fields later. Having an unique payload type per mutation you won't break other mutations when editing current mutation.

Do not return scalar type as mutation response. Возвращая данные напрямую (без обертки в Payload-тип), вы лишаете себя возможности в будущем легко добавить дополнительные поля для возврата. GraphQL APIs don't have versioning and work best when types are expandable not editable. Using an unique payload type is investment in the future of API.

```diff
type Mutation {
-  createPerson(input: ...): Person                # BAD
+  createPerson(input: ...): CreatePersonPayload   # GOOD
}

+ type CreatePersonPayload {
+   recordId: ID
+   record: Person
+   # ... любые другие поля, которые пожелаете
+ }
```

Важно отметить, что возвращаемые поля в вашем Payload-типе должны быть nullable (необязательными). As we can see если вы будите возвращать ошибку например в поле `userErrors`, то вы не сможете гарантировать наличие данных в поле `record`. Этот момент может всплыть, когда фронтендеры начнут вас просить сделать эти поля обязательными, т.к. статический анализ заставляет их делать дополнительную проверку на наличие данных. Вы спокойно должны им сказать, что им необходимо делать проверку, ведь данные реально могут отсутствовать.

- [6.6.1.](./6.6.1-payload-record.md) Return changed resource `id` in mutation response.
- [6.6.2.](./6.6.2-payload-status.md) Return operation status in mutation response.
- [6.6.3.](./6.6.3-payload-query.md) Return field with type `Query` in mutation response.
- [6.6.4.](./6.6.4-payload-errors.md) Return a typed field `errors` describing user errors.