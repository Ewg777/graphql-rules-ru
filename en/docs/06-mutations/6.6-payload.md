### <a name="rule-6.6"></a> 6.6. Every mutation should have a unique payload type.

Use a unique payload type for every mutation. This way you'll be able to expand mutation response with additional fields later. While having a unique payload type per mutation, will make sure that you won't break other mutations when editing the current one.

Even if you want to return only one record from your mutation, don't be tempted to return that type directly. Возвращая данные напрямую (без обертки в Payload-тип), вы лишаете себя возможности в будущем легко добавить дополнительные поля для возврата. GraphQL version-less API works well when the types are expanding, not changing. Using a unique payload type is an investment in the future of the API.

```diff
type Mutation {
-  createPerson(input: ...): Person                # BAD
+  createPerson(input: ...): CreatePersonPayload   # GOOD
}

+ type CreatePersonPayload {
+   recordId: ID
+   record: Person
+   # ... any other fields you like
+ }
```

It is important to note that the fields returned in your Payload type must be nullable (optional). As we can see if you will return an error, for example, in the field `userErrors`, then you can not guarantee the availability of data in the field `record`. This point may come up when clients will start asking you to make these fields mandatory, because static analysis forces them to do additional checks for data. You calmly have to tell them that they need to do the check, because the data may actually be missing.

- [6.6.1.](./6.6.1-payload-record.md) In the mutation response, return the modified resource and its `id`.
- [6.6.2.](./6.6.2-payload-status.md) Return operation status in mutation response.
- [6.6.3.](./6.6.3-payload-query.md) In the mutation response, return a field of type `Query`.
- [6.6.4.](./6.6.4-payload-errors.md) In the mutation response, return the `errors` field with typed user errors.