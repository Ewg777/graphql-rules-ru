### <a name="rule-6.3"></a> 6.3. Рассмотрите возможность выполнения мутаций сразу над несколькими элементами (однотипные batch-изменения).

A rule adjusted at remarks: Ivan Goncharov #42 date of last revision: 17.05.2019

```diff
type ArticleMutations {
-  deleteArticle(id: Int!): Payload
+  deleteArticle(id: [Int!]!): Payload
}

```

Client applications become smarter and more convenient. Often, the user is offered batch operations – adding multiple records, mass deletion or sorting. It will be expensive to send operations one by one. Somehow aggregating them into a complex GraphQL query with several mutations, i.e. dynamically generating one common query on the client is a completely disgusting idea:

```graphql
mutation DeleteArticles { # BAD
  op1: deleteArticle(id: 1)
  op2: deleteArticle(id: 2)
  op3: deleteArticle(id: 5)
  op4: deleteArticle(id: 5)
}
```

If the GraphQL query is dynamically created in the runtime (the query body itself, not the collection of variables) – then most likely you are doing something wrong. The request form should be defined by the developers at the stage of writing the code. This allows linters and static analyzers to check queries; and allows you to "compile" a query (convert to AST) for Relay/Apollo. When dynamically generating a request on the client, all these checks and optimizations are lost in the browser.

Thanks to the GraphQL specification - List Input Coercion, you can declare the id argument as an array id: [Int!]!, then clients will be able to pass in their queries as a simple number and an array:

```graphql
mutation DeleteArticles {
  op1: deleteArticle(id: [1, 2, 5]) # works
  op2: deleteArticle(id: 7) # works too
}
```

Тоже самое работает, если использовать переменные (можно посмотреть [тесты](./__tests__/list-coercion-test.js)):

```js
await graphql({
  schema,
  source: `
    mutation DeleteArticles($id: [Int!]!) {
      deleteArticle(id: $id)
    }
  `,
  variableValues: { id: 777 }, // Should be `Array`, but works with `Int` too
});
```

Также иногда бекендерам важно понимать, что происходит массовая операция. Because at the parsing and validation stage of your query GraphQL will do that check by itself and will fail query with exception if value is not present. можно оптимизировать логику или побочные эффекты, например отправить 1 нотификацию или 1000.