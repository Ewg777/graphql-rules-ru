### <a name="rule-3.3"></a> 3.3. Достигайте максимальной группировки взаимосвязанных полей.

#### Проблема:

Бывают случаи, когда в зависимости от определенного значения мы ожидаем те или иные параметры. К примеру, у нас есть жалобы `Claim` которые поступают либо по почте, либо по телефону. Поле `operatorCode` содержит в себе код оператора, который принял звонок. Т.е. оно всегда заполнено если указан телефон, и пустое если жалоба пришла по почте.

```graphql
type Claim {
  text: String!
  phone: String
  operatorCode: String
  email: String
}
```

#### Цель:

Укажем тип жалобы `Claim` таким образом, чтобы максимально описать поля, которые мы обязательно получим в том или ином случае. Благодаря этому, клиенту придется делать меньше проверок.

#### Решения:

В примере схемы, указанной выше, Вы можете увидеть отсутствие описания обязательных полей, т.е. все поля являются nullable (кроме text, о котором речь не пойдет), поэтому клиенту придется дополнительно проверять каждое значение перед работой с ним.

##### Существует несколько решений этой проблемы:

1) Сгруппировать взаимосвязанные поля на уровень ниже в новый output-тип 2) Использовать union-типы в связке с fragments

##### Решение 1: Группировка взаимосвязанных полей вместе в новый output-тип

Выносите взаимосвязанные поля на уровень ниже в новый output-тип. Берем поля `phone` и `operatorCode` и группируем их в типе `ClaimByPhone`. Тогда нашу схему можно представить в следующем виде:

```graphql
type Claim {
  text: String!
  byPhone: ClaimByPhone
  byMail: ClaimByMail
}

type ClaimByPhone {
  phone: String!
  operatorCode: String!
}

type ClaimByMail {
  email: String!
}
```

Обратите внимание, что если поле `byPhone` не пустое, то оно обязательно будет содержать номера телефона и кода оператора. Становится возможным взаимосвязанные поля делать обязательными.

##### Решение 2: Использование Union типов в связке с fragments

Если вы не знакомы с Union типами, их можно описать как "либо либо". Подробнее про Union типы следует почитать [тут](https://github.com/nodkz/conf-talks/tree/master/articles/graphql/types#union-types).

```graphql
# Опишем базовый тип для жалобы
type ClaimBase {
  text: String!
}

# Опишем тип жалобы, пришедшей по телефону
type ClaimByPhone implements ClaimBase {
  text: String!
  phone: String!
  operatorCode: String!
}

# Опишем тип жалобы, пришедшей по почте
type ClaimByMail implements ClaimBase {
  text: String!
  email: String!
}

# Опишем union тип жалобы
union Claim = ClaimByPhone | ClaimByMail

```

Теперь клиент запрашивает claim с помощью фрагментов, запрос выглядит так:

```graphql
query {
  claim {
    ... on ClaimByPhone {
      text
      phone
      operatorCode
    }
    ... on ClaimByMail {
      text
      email
    }
  }
}
```

Такой подход делает схему более строгой, облегчает фронтендерам восприятие взаимосвязанных полей.