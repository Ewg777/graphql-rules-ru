## 4. Правила аргументов

### <a name="rule-4.1"></a> 4.1. Группируйте взаимосвязанные аргументы вместе в новый input-тип.

Часто бывают ситуации, когда несколько аргументов по логике взаимосвязаны друг с другом. К примеру вы возвращаете список статей `[Article]`, и позволяете этот список фильтровать по трем полям `lang`, `userId`, `rating` и ограничивать размер выборки `limit`. Крайне нежелательно смешивать все эти аргументы на одном уровне:

- клиенту будет тяжело понять к чему какой аргумент относится
- в будущем у вас может возникнуть проблема, что одно имя аргумента уже используется для других целей.

Смело группируйте взаимосвязанные аргументы, например все аргументы фильтрации можно положить в аргумент `filter` с типом `ArticleFilter`:

```graphql
type Query {
  articles(filter: ArticleFilter, limit: Int): [Article]
}

input ArticleFilter {
  lang: Stirng
  userId: Int
  rating: MinMaxInput
}

input MinMaxInput {
  min: Int
  max: Int
}
```

Из кода выше, также обратите внимание как поступили с фильтрацией по полю `rating`. Вместо двух разрозненных полей `ratingMin` и `ratingMax` был заведен новый input-тип `MinMaxInput`.

В общем если сгруппировать взаимоувязанные аргументы в под-тип, то это делает схему не только легче для восприятия, но и позволяет достаточно легко ее расширять в будущем.

### <a name="rule-4.2"></a> 4.2. Используйте строгие скалярные типы для аргументов, например `DateTime` вместо `String`.

Используйте более строгие типы для входных данных. Например, скалярный тип `DateTime` вместо `String`. Как вы знаете в GraphQL всего 5 скалярных типов и типа для `дат` в нем нет. Но в GraphQL есть возможность создания своих скалярных типов, которая позволяет задать описание и написать методы валидации, сериализации и десериализации полученных значений.

```diff
type Mutation {
-  setTime(date: String):   SetTimePayload  # BAD
+  setTime(date: DateTime): SetTimePayload  # GOOD
}
```

Во-первых, это позволяет вам единожды описать методы конвертации значений от клиента в серверное представление (в нашем примере в объект Date).

Во-вторых, это обеспечивает ясность и побуждает клиентов использовать более строгие элементы управления вводом (например, виджет выбора даты вместо поля с произвольным текстом).

А вот и пример создания такого скалярного типа в Node.js:

```js
import { GraphQLScalarType, GraphQLError } from 'graphql';

export default new GraphQLScalarType({
  // 1) --- ОПРЕДЕЛЯЕМ МЕТАДАННЫЕ ТИПА ---
  // У каждого типа, должно быть уникальное имя
  name: 'DateTime',
  // Хорошим тоном будет предоставить описание для вашего типа, чтобы оно отображалось в документации
  description: 'A string which represents a HTTP URL',

  // 2) --- ОПРЕДЕЛЯЕМ КАК ТИП ОТДАВАТЬ КЛИЕНТУ ---
  // Чтобы передать клиенту в GraphQL-ответе значение вашего поля
  // вам необходимо определить функцию `serialize`,
  // которая превратит значение в допустимый json-тип
  serialize: (v: Date) => v.getTime(), // return 1536417553

  // 3) --- ОПРЕДЕЛЯЕМ КАК ТИП ПРИНИМАТЬ ОТ КЛИЕНТА ---
  // Чтобы принять значение от клиента, провалидировать его и преобразовать
  // в нужный тип/объект для работы на сервере вам нужно определить две функции:

  // 3.1) первая это `parseValue`, используется если клиент передал значение через GraphQL-переменную:
  // {
  //   variableValues: { "date": 1536417553 }
  //   source: `query ($date: DateTimestamp) { setDate(date: $date) }`
  // }
  parseValue: (v: integer) => new Date(v),

  // 3.2) вторая это `parseLiteral`, используется если клиент передал значение в теле GraphQL-запроса:
  // {
  //   source: `query { setDate(date: 1536417553) }`
  // }
  parseLiteral: (ast) => {
    if (ast.kind === Kind.STRING) {
      throw new GraphQLError('Field error: value must be Integer');
    } else if (ast.kind === Kind.INT) {
      return new Date(parseInt(ast.value, 10)); // ast value is always in string format
    }
    return null;
  },
});
```

### <a name="rule-4.3"></a> 4.3. Помечайте аргументы как `required`, если они обязательны для выполнения запроса.

По умолчанию, все поля и аргументы в GraphQL являются `nullable` – необязательными. Поэтому хорошим тононом будет помечать обязательные аргументы для выполнения запроса как `GraphQLNonNull` или если в формате SDL то с восклицательным знаком – `String!`. Это позволит отловить ошибку на клиенте еще на уровне статического анализа кода, а не в рантайме.

Плюс, если вы указали что аргумент обязательный, то на сервере в своем resolve-методе вы можете быть уверены, что данное значение присутствует и его не нужно проверять на наличие. Т.к. во время парсинга и валидации запроса GraphQL уже сделает эту проверку, и завернет запрос с ошибкой если значение не указано.

Например, для получения списка статей клиент должен указать кол-во возвращаемых записей:

```graphql
type Query {
  articles(limit: Int!): [Article]
}
```

Хотя, иногда злодействовать не стоит и можно воспользоваться значением по умолчанию:

```graphql
type Query {
  articles(limit: Int! = 10): [Article]
}
```

Тогда клиент может не передавать значение для обязательного аргумента `limit`, оно будет равно по умолчанию 10. Но если вдруг клиент захочет надурачить систему и в запросе передаст null – `query { articles(limit: null) }`, то сервер вернет ошибку `Expected type Int!, found null.`.

В общем обязательные аргументы в GraphQL работают хорошо и их стоит использовать для более строгого описания вашей GraphQL-схемы.
